>> nice code for dumping textures inside of push buffer stuff

            /*
            IDirect3DBaseTexture8 *pTexture = 0;

            g_pD3DDevice8->GetTexture(0, &pTexture);
    
            if(pTexture != NULL)
            {
                static int dwDumpTexture = 0;

                char szBuffer[256];

                printf("Texture Time...\n");

                switch(pTexture->GetType())
                {
                    case D3DRTYPE_TEXTURE:
                    {
                        printf("_TEXTURE\n");
                        sprintf(szBuffer, "C:\\Aaron\\Textures\\PushBufferTex - %.03d (0x%.08X).bmp", dwDumpTexture++, pTexture);

                        ((IDirect3DTexture8*)pTexture)->UnlockRect(0);

                        D3DXSaveTextureToFile(szBuffer, D3DXIFF_BMP, pTexture, NULL);
                    }
                    break;

                    case D3DRTYPE_CUBETEXTURE:
                    {
                        printf("_CUBETEXTURE\n");
                        for(int face=0;face<6;face++)
                        {
                            sprintf(szBuffer, "C:\\Aaron\\Textures\\PushBufferTexCube%d - %.03d (0x%.08X).bmp", face, dwDumpTexture++, pTexture);

                            ((IDirect3DCubeTexture8*)pTexture)->UnlockRect((D3DCUBEMAP_FACES)face, 0);
                            
                            D3DXSaveTextureToFile(szBuffer, D3DXIFF_BMP, pTexture, NULL);
                        }
                    }
                    break;
                }
            }
            //*/

<<

>>

    /* TODO: Use new handle wrapping code

    // ******************************************************************
    // * For now, just check for 'special' cases
    // ******************************************************************
    if(strcmp(ObjectAttributes->ObjectName->Buffer, "\\Device\\Harddisk0\\partition1\\") == 0)
    {
        EmuHandle *iEmuHandle = new EmuHandle;

        iEmuHandle->m_Type = EMUHANDLE_TYPE_PARTITION1;

        *FileHandle = PtrToEmuHandle(iEmuHandle);
    }
    else if(strcmp(ObjectAttributes->ObjectName->Buffer, "\\Device\\Harddisk0\\partition1\\TDATA") == 0)
    {
        EmuHandle *iEmuHandle = new EmuHandle;

        iEmuHandle->m_Type = EMUHANDLE_TYPE_TDATA;

        *FileHandle = PtrToEmuHandle(iEmuHandle);

        // TODO: Update IoStatusBlock if necessary
    }
    else
    {
        EmuPanic();
    }
    */
	
<<

	__asm int 3
	wchar_t wszObjectName[160];

	xntdll::UNICODE_STRING    NtUnicodeString;
	xntdll::OBJECT_ATTRIBUTES NtObjAttr;

    setlocale(LC_ALL, "English");
    mbstowcs(wszObjectName, ObjectAttributes->ObjectName->Buffer, 160);

	NT_RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

	// Initialize NtObjAttr
	NtObjAttr.Length = sizeof(xntdll::OBJECT_ATTRIBUTES);

	InitializeObjectAttributes(&NtObjAttr, &NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);

    NTSTATUS ret = NT_NtCreateFile
    (
        FileHandle, DesiredAccess, &NtObjAttr, (xntdll::IO_STATUS_BLOCK*)IoStatusBlock,
        (xntdll::LARGE_INTEGER*)AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, NULL, NULL
    );

	if(FAILED(ret))
		MessageBox(g_hEmuWindow, "Bad!", "Cxbx", MB_OK);
	else
		MessageBox(g_hEmuWindow, "Good!", "Cxbx", MB_OK);


<<

// ******************************************************************
// * calculate TLS adjustment
// ******************************************************************
uint32 TlsAdjust = 0;

if(x_Xbe->m_TLS == 0)
    TlsAdjust = -1;
else
{
    // ******************************************************************
    // * necessary tls adjustment values
    // ******************************************************************
    uint32 TlsZF = x_Xbe->m_TLS->dwSizeofZeroFill;
    uint32 TlsEA = x_Xbe->m_TLS->dwDataEndAddr;
    uint32 TlsSA = x_Xbe->m_TLS->dwDataStartAddr;
    
    // ******************************************************************
    // * calculate tls adjustment
    // ******************************************************************
    TlsAdjust  = (TlsZF - TlsSA) + TlsEA + 0x0F;
    TlsAdjust &= 0xFFFFFFF0;
    TlsAdjust += 4;
}

>> unused OpenXDK logo bitmap (OpenXDK.cpp)

// OpenXDK logo bitmap
uint08 OpenXDK[] =
{
    0x5A, 0x06, 0x23, 0x49, 0x13, 0x0F, 0x33, 0x49, 0x13, 0x0F,
    0x13, 0x4F, 0x33, 0x0D, 0x13, 0x49, 0x23, 0x46, 0x00, 0x23,
    0x4D, 0x33, 0x0D, 0x13, 0x43, 0x22, 0x00, 0x43, 0x13, 0x22,
    0x00, 0xC3, 0x22, 0xF0, 0xC3, 0x05, 0x33, 0xD3, 0x22, 0xF0,
    0x83, 0x09, 0x73, 0x2A, 0xF0, 0x07, 0x83, 0x22, 0xF0, 0xD3,
    0x33, 0x03, 0x73, 0xC3, 0x33, 0x0B, 0x33, 0xC3, 0x73, 0x05,
    0x73, 0x22, 0xF0, 0xE3, 0x63, 0x07, 0x43, 0xF3, 0x22, 0x00,
    0xF3, 0x43, 0x22, 0x00, 0xF3, 0x73, 0x33, 0x09, 0x33, 0x73,
    0xF3, 0x05, 0x43, 0xF3, 0x43, 0x23, 0x07, 0x13, 0x43, 0x93,
    0xB3, 0x09, 0x73, 0xC3, 0x13, 0x0D, 0x45, 0x07, 0xB3, 0x93,
    0x43, 0x09, 0x23, 0x43, 0xF3, 0x43, 0x03, 0x13, 0xA3, 0xF3,
    0x73, 0x07, 0x73, 0xF3, 0xA3, 0x13, 0x05, 0x73, 0xB3, 0x0B,
    0x13, 0x43, 0xC3, 0x73, 0x07, 0x43, 0xF3, 0x22, 0x00, 0xF3,
    0x43, 0x22, 0x00, 0xF3, 0x43, 0x0D, 0x43, 0xF3, 0x23, 0x73,
    0x93, 0xF3, 0x7F, 0xB5, 0x05, 0x75, 0xB3, 0xD3, 0x7D, 0x63,
    0x0B, 0xB3, 0x73, 0x0F, 0xF3, 0x43, 0x07, 0x53, 0xE3, 0xC3,
    0x63, 0xC3, 0xE3, 0x53, 0x09, 0x73, 0xB3, 0x0F, 0xB3, 0x73,
    0x03, 0x63, 0x73, 0x93, 0xF3, 0x7B, 0x83, 0xB3, 0xD3, 0xF3,
    0x43, 0x22, 0x00, 0xF3, 0x43, 0x0D, 0x43, 0xF3, 0x33, 0xB3,
    0xC3, 0xF3, 0xBD, 0xA3, 0x73, 0x63, 0x05, 0xB5, 0xD3, 0xE3,
    0xBD, 0x83, 0x0B, 0xB3, 0x73, 0x0F, 0xF3, 0x43, 0x09, 0x13,
    0xE3, 0xF3, 0xE3, 0x13, 0x0B, 0x73, 0xB3, 0x0F, 0xB3, 0x73,
    0x03, 0x83, 0xB3, 0xC3, 0xF3, 0xBB, 0xD3, 0xF5, 0xB3, 0x23,
    0x22, 0x00, 0xF3, 0x43, 0x0D, 0x43, 0xF3, 0x05, 0x43, 0xF3,
    0x36, 0x00, 0x73, 0xB3, 0x32, 0x00, 0xB3, 0x73, 0x0F, 0xF3,
    0x43, 0x07, 0x33, 0xC3, 0xE3, 0x73, 0xE3, 0xC3, 0x33, 0x09,
    0x73, 0xB3, 0x0F, 0xB3, 0x73, 0x07, 0x43, 0xF3, 0x0D, 0x13,
    0x43, 0xF3, 0x43, 0x22, 0x00, 0xF3, 0xC3, 0xA3, 0x79, 0xA3,
    0xC3, 0xF3, 0x05, 0x43, 0xF3, 0x36, 0x00, 0x73, 0xE3, 0x93,
    0x7B, 0x93, 0xB3, 0xC3, 0x07, 0xB3, 0x73, 0x0F, 0xF3, 0x43,
    0x05, 0x73, 0xF3, 0xA3, 0x13, 0x03, 0x13, 0xA3, 0xF3, 0x73,
    0x07, 0x73, 0xD3, 0x7B, 0x83, 0xB3, 0xE3, 0x73, 0x07, 0x43,
    0xF3, 0x22, 0x00, 0xF3, 0x43, 0x22, 0x00, 0x53, 0x73, 0x83,
    0xB9, 0x93, 0x73, 0x53, 0x05, 0x33, 0xB3, 0x36, 0x00, 0x43,
    0x73, 0xA3, 0xBD, 0x83, 0x73, 0x07, 0x83, 0x63, 0x0F, 0xB3,
    0x33, 0x03, 0x63, 0xE3, 0x53, 0x0B, 0x53, 0xE3, 0x63, 0x05,
    0x63, 0xBF, 0x75, 0x23, 0x07, 0x33, 0xB3, 0x22, 0x00, 0xB3,
    0x33, 0xFA, 0x00, 0x13, 0x0F, 0x13, 0xBE, 0x06, 0x03,
};

// size, in bytes, of the OpenXDK logo bitmap
uint32 dwSizeOfOpenXDK = 0x0000017B;

<<